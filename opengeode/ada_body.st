group adb;

/* top-level: template for the code of a process
 * name: process name
 * dcl: list of local declarations
 * pdecl : inner procedure declarations (array)
 * pcode : inner procedure code (array)
 * vars: list of local variables and sort: { name: str, sort: str })
 * arrs_inp : code handling the reception of messages (array of <input_signal>)
 * arrs_async_ri : code for the required interfaces
 * constants: list of start named start transitions (when using substates)
 * states: list of states
 * asn1_mod : list of ASN.1 modules
 * simu, dll : flags set by the user for generation of optional code
 * ext_proc : external procedure declarations (array)
 * timer_decls : declaration of timers (array)
 * timer_defs : definition of timers (array)
 * tr_locals : local variables used in transitions/floating labels (array)
 * tr_code : code of the transitions (array)
 * flab_code : code of the floating labels
*/
process(name, decl, pdecl, pcode vars, arrs_inp, arrs_async_ri, constants, states, asn1_mod, simu, dll, ext_proc, timer_decls, timer_defs, tr_locals, tr_code, flab_code) ::= <<
--  This file was generated automatically: DO NOT MODIFY !

<if(asn1_mod)>
--  ASN.1 Modules used by this process, and generated by ASN1SCC
<asn1_mod: {each |
with <each>;
use <each>;}; separator="\n">

-- ASN.1 Runtime, containing basic types
with AdaASN1rtl;
use AdaASN1rtl;
<endif>


--  Include Ada generic libraries used by the generated code
with System.IO;
use System.IO;

with Ada.Unchecked_Conversion;
with Ada.Numeric.Generic_Elementary_Functions;

with Interfaces;
use Interfaces;

<if(simu)>
--  Access to C compatible types when interacting with another language
with Interfaces.C.Strings;
use Interfaces.C.Strings;

<endif>

package body <name> is
    <if(dcl)>
    --  Local variables declared in textboxes
    <dcl; separator="\n">
    <endif>
    ---------------------------------------------------------------------------
    --  List of SDL states, and variable holding the current state
    type States is (<states; separator=", ">);
    state: States;
    <if(pdecl)>
    --  Declaration of inner procedures
    <pdecl; separator="\n">
    <endif>

    <if(simu)>
    --  External API to get/set the SDL state from a remote C application
    function get_state return chars_ptr is (New_String(States'Image(state)))
        with Export, Convention => C, Link_Name => "<name>_state";
    procedure set_state(new_state: chars_ptr);
    pragma export(C, set_state, "_set_state");
    ---------------------------------------------------------------------------
    <endif>
    <if(constants)>
    --  Constants holding substate identifier for the start transition
    <constants; separator="\n">
    ---------------------------------------------------------------------------
    <endif>
    --  Declaration of the procedure executing transitions
    procedure RunTransition(Id: Integer);

    <if(simu)>
    --  Implementation of the set_state procedure
    procedure set_state(new_state: chars_ptr) is
    begin
        state := States'Value(Value(new_state));
    end set_state;
    --  Implementation of the variable setters for external C access
    <vars: {each |
procedure dll_set_l_<each.name>(value: access <each.sort>) is
begin
    l_<each.name> := value.all;
end dll_set_l_<each.name>;
    }; separator="\n">
    ---------------------------------------------------------------------------
    <endif>
    <pcode; separator="\n">
    <arrs_inp; separator = "\n">
    <arrs_ri; separator = "\n">
    <timer_defs; separator = "\n">

    procedure RunTransition(id: integer) is
        tdId : integer := id;
        <tr_locals; separator = "\n">
    begin
        while (trId /= -1) loop
            case trId is
                <tr_code; separator = "\n">
                when others => null;
            end case;
        <if(flab_code)>
        goto next_transition;
        <flab_code>
        <endif>
        \<\<next_transition\>\>
        null;
        end loop;
    end RunTransition;

    --  Process initialization: execute the START transition)
    begin
        RunTransition(0);
end <name>;
>>

transition_code(idx, code) ::= <<
when <idx> =>
    <if(code)><code><else>null;<endif>
>>


/* Variable declaration (DCL var sort [:= def_expr]; */
dcl(var, def_expr, simu) ::= <<
l_<var.name> : aliased <var.sort><if(def_expr)> := <def_expr><endif>;
<if(simu)>
function l_<var.name>_size return Integer is (l_<var.name>'Size/8)
    with Export, Convention => C, Link_Name => "<var.name>_size";
function l_<var.name>_value return access <var.sort> is (l_<var.name>'access)
    with Export, Convention => C, Link_Name => "<var.name>_value";
procedure dll_set_l_<var.name>(value: access <var.sort>);
pragma Export(C, dll_set_l_<var.name>, "_set_<var.name>");
<endif>
>>

/* Timer set/reset declaration, ctxt = process name*/
timer_declaration(name, simu, ctxt) ::= <<
<if(simu)>
--  Timer <name> SET and RESET functions
type SET_<name>_T is access procedure (name: chars_ptr; duration: integer);
pragma Convention(Convention => C, Entity => SET_<name>_T);
type RESET_<name>_T is access procedure (name: chars_ptr);
pragma Convention(Convention => C, Entity => RESET_<name>_T);
SET_<name> : SET_<name>_T;
procedure Register_SET_<name>(Callback: SET_<name>_T);
pragma Export(C, Register_SET_<name>, "register_SET_<name>");
RESET_<name> : RESET_<name>_T;
procedure Register_RESET_<name>(Callback: SET_<name>_T);
pragma Export(C, Register_RESET_<name>, "register_RESET_<name>");
<else>
procedure SET_<name>(val: access asn1SccT_UInt32);
pragma Import(C, SET_<name>, "<ctxt>_RI_set_<name>");
procedure RESET_<name>;
pragma Import(C, RESET_<name>, "<ctxt>_RI_reset_<name>);
<endif>
>>

timer_definition(name, simu, ctxt) ::= <<
<if(simu)>
procedure Register_SET_<name>(Callback: SET_<name>_T) is
begin
    SET_<name> := Callback;
end Register_SET_<name>;

procedure Register_RESET_<name>(Callback: RESET_<name>_T) is
begin
    RESET_<name> := Callback;
end Register_RESET_<name>;
<endif>
>>

/* Code for a provided interface or timer timout signal */
input_signal(header, name, process, cases) ::= <<
--  Provided interface <name>
<header> is
    begin
       case state is
            <cases>
            when others =>
                null;
        end case;
end <name>;

>>

/* Case state to be used to select what transition to run
   When leaving a state, it may be necessary to call the exit procedure of
   inner states. The list of such procedures is in arrs_exitproc.
   There can also be parameters (only one in practice at the moment), which
   have to be assigned to a local variable: they are in arrs_param_assig
*/
case_state(name, arrs_exitproc, arrs_param_assig, transition) ::= <<
when <name> =>
    <arrs_param_assig; separator="\n">
    <arrs_exitproc: {each | p<safe_separator()><each><safe_separator()>exit;};separator="\n">
    <if(transition)>runTransition(<transition>);<else>null;<endif>
>>

/* Assign a parameter of an input signal to a local variable */
assign_param(local_var, param_name) ::= "l_<local_var> := <param_name>.all;"

/* Provided interface header, used in declaration and definition */
pi_signature(name, param_name, param_sort) ::= <<
procedure <name>
<if(param_sort)>
(<if(param_name)><param_name><else><name>_param<endif>: access <param_sort>)
<endif>
>>

/* Code for a (stateless) inner procedure */
inner_procedure_definition(header, name, dcl, other_decl, start, labels) ::= <<
<header> is
    <if(dcl)>
    --  Procedure local variables declared in textboxes
    <dcl; separator="\n">
    <endif>
    <if(other_decl)>
    --  Other local declarations needed to support all SDL constructs
    <other_decl; separator="\n">
    <endif>
    begin
        <start>
        <if(!start)>
        null;  --  Empty procedure
        <endif>
        <labels>
end p<safe_separator()><name>;

>>


inner_procedure_declaration(header, name, external) ::= <<
<header>;
<if(external)>
pragma import(C, <name>);
<endif>
>>


/* Header of an inner procedure */
inner_procedure_signature(name, external, fpar) ::= <<
procedure <if(!external)>p<safe_separator()><endif><name>
<if(fpar)>
(<fpar: {each| l_<each.name>: <each.direction> <each.sort>}; separator="; ">)
<endif>
>>


/* Header of an external procedure */
ext_procedure_signature(name, fpar) ::= <<
procedure <name>
<if(fpar)>
(<fpar: {each| <each.name>: access <each.sort>}; separator="; ">)
<endif>
>>

/* Declaration of an external procedure.
   header is obtained from ext_procedure_signature
   name is the name of the procedure
   ctxt is the context (process) name 
*/
ext_procedure_declaration(header, name, ctxt) ::= <<
--  Synchronous required interface <<name>>
<header>;
pragma import(C, <name>, "<ctxt>_RI_<name>");
>>



/* Code for external RI */
required_interface(name, simu) ::= <<
<if(simu)>
procedure Register_<name>(Callback: <name>_T) is
begin
    <name> := Callback;
end Register_<name>;
<endif>
>>


/* Template for floating labels */
floating_label(name, traceability, transition) ::= <<
<traceability>
\<\<<name>\>\>
    <transition>
<if(!transition)>
    return;
<endif>
>>

/* Template for a label within a procedure, i.e connecting to a floating */
label(name) ::= "goto <name>;"

/* Constant declaration */
constant(var, val) ::= "<var> : constant := <val>;"

direction_in() ::= "in"
direction_out() ::= "in out"

comment(lines) ::= "--  <lines; separator="\n--  ">"

safe_separator() ::= "<\u00dc>"
